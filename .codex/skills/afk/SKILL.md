---
name: afk
description: 在项目开发中启用“AFK 模式”参数化执行：当用户明确开启后，尽量减少二次确认并持续推进任务；当用户关闭后恢复常规交互确认节奏。用于“我 AFK 了你继续做”“减少确认直接推进”“afk on/off”这类场景，适合多步骤实现、修复、测试与提交流程。
---

# Afk

按以下规范执行，目标是在安全边界内最大化连续推进效率。

## 1) 模式开关（参数驱动）

- 使用显式参数控制状态：
  - `afk=on`：开启 AFK 模式
  - `afk=off`：关闭 AFK 模式
- 仅在用户明确设置时切换状态；未设置时保持当前状态。
- 在每次关键回复开头简短回报当前状态，例如：`AFK 模式：ON`。

## 2) AFK=ON 时的执行策略

- 默认直接执行，不重复确认已明确目标。
- 优先自行补全低风险缺省项（如命名、顺序、测试命令），并在结果中说明采用了哪些假设。
- 对多步骤任务连续推进到可交付节点（代码 + 测试 + 文档），中途仅在必要时打断。
- 优先先做可验证动作（读代码、跑测试、静态检查）再做高影响修改。

## 3) 必须询问的最小集合（即使 AFK=ON）

仅在以下场景提问，且一次只问最关键问题：

- 存在不可逆或高破坏风险（如大规模删除、重置历史、覆盖用户未确认数据）。
- 出现互斥需求且无法从上下文判定优先级。
- 执行受阻（权限、缺失凭据、外部依赖不可达）且无可行替代路径。
- 任何必须由用户批准的宿主权限提升请求（按系统机制发起）。

## 4) AFK=OFF 时行为

- 恢复常规协作风格：遇到关键分支决策先确认，再继续执行。
- 不强制改变既有工作流，仅关闭“尽量不二次确认”的偏好。

## 5) 输出要求（AFK 模式）

- 用简短进度块汇报：已完成、进行中、下一步。
- 明确列出“自动假设”与“未决风险”，避免静默决策。
- 完成一个里程碑后再集中汇报，不做高频打断。

## 6) 触发示例

- “afk=on，继续把这个迭代做完，尽量别问我。”
- “先开 AFK，修完测试失败再提交。”
- “afk=off，后面关键点先问我。”

## 7) 约束与边界

- AFK 模式不会绕过系统安全策略、沙箱限制与审批机制。
- AFK 模式不会覆盖用户明确指令；用户最新指令始终优先。
